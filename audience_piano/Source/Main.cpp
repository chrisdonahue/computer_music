/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic startup code for a Juce application.

  ==============================================================================
*/

#include <cstdio>
#include <cstdlib>
#include <process.h>

#include <libwebsockets.h>

#include "../JuceLibraryCode/JuceHeader.h"

#include "MainComponent.h"

static volatile int force_exit = 0;
static int versa, state;

#define MAX_ECHO_PAYLOAD 1400
#define LOCAL_RESOURCE_PATH INSTALL_DATADIR"/libwebsockets-test-server"

struct per_session_data__echo {
	unsigned char buf[LWS_SEND_BUFFER_PRE_PADDING + MAX_ECHO_PAYLOAD + LWS_SEND_BUFFER_POST_PADDING];
	unsigned int len;
	unsigned int index;
};

static int
callback_echo(struct libwebsocket_context *context,
struct libwebsocket *wsi,
enum libwebsocket_callback_reasons reason, void *user,
	void *in, size_t len)
{
	struct per_session_data__echo *pss = (struct per_session_data__echo *)user;
	int n;

	switch (reason) {

#ifndef LWS_NO_SERVER
		/* when the callback is used for server operations --> */

	case LWS_CALLBACK_SERVER_WRITEABLE:
	do_tx :
		n = libwebsocket_write(wsi, &pss->buf[LWS_SEND_BUFFER_PRE_PADDING], pss->len, LWS_WRITE_TEXT);
		  if (n < 0) {
			  lwsl_err("ERROR %d writing to socket, hanging up\n", n);
			  return 1;
		  }
		  if (n < (int)pss->len) {
			  lwsl_err("Partial write\n");
			  return -1;
		  }
		  break;

	case LWS_CALLBACK_RECEIVE:
	do_rx :
		if (len > MAX_ECHO_PAYLOAD) {
			lwsl_err("Server received packet bigger than %u, hanging up\n", MAX_ECHO_PAYLOAD);
			return 1;
		}
		  memcpy(&pss->buf[LWS_SEND_BUFFER_PRE_PADDING], in, len);
		  pss->len = (unsigned int)len;
		  libwebsocket_callback_on_writable(context, wsi);
		  break;
#endif

#ifndef LWS_NO_CLIENT
		  /* when the callback is used for client operations --> */

	case LWS_CALLBACK_CLOSED:
	case LWS_CALLBACK_CLIENT_CONNECTION_ERROR:
		lwsl_info("closed\n");
		state = 0;
		break;

	case LWS_CALLBACK_CLIENT_ESTABLISHED:
		lwsl_notice("Client has connected\n");
		pss->index = 0;
		state = 2;
		break;

	case LWS_CALLBACK_CLIENT_RECEIVE:
#ifndef LWS_NO_SERVER
		if (versa)
			goto do_rx;
#endif
		lwsl_notice("Client RX: %s", (char *)in);
		break;

	case LWS_CALLBACK_CLIENT_WRITEABLE:
#ifndef LWS_NO_SERVER
		if (versa)
			goto do_tx;
#endif
		/* we will send our packet... */
		pss->len = sprintf((char *)&pss->buf[LWS_SEND_BUFFER_PRE_PADDING], "hello from libwebsockets-test-echo client pid %d index %d\n", getpid(), pss->index++);
		lwsl_notice("Client TX: %s", &pss->buf[LWS_SEND_BUFFER_PRE_PADDING]);
		n = libwebsocket_write(wsi, &pss->buf[LWS_SEND_BUFFER_PRE_PADDING], pss->len, LWS_WRITE_TEXT);
		if (n < 0) {
			lwsl_err("ERROR %d writing to socket, hanging up\n", n);
			return -1;
		}
		if (n < (int)pss->len) {
			lwsl_err("Partial write\n");
			return -1;
		}
		break;
	case LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS:

		break;
#endif
	default:
		break;
	}

	return 0;
}

static struct libwebsocket_protocols protocols[] = {
	/* first protocol must always be HTTP handler */
	{
		"handler_http",		/* name */
		callback_echo,		/* callback */
		sizeof(struct per_session_data__echo)	/* per_session_data_size */
	},
	{
		NULL, NULL, 0		/* End of list */
	}
};

//==============================================================================
class audience_pianoApplication  : public JUCEApplication
{
public:
    //==============================================================================
    audience_pianoApplication() {}

    const String getApplicationName() override       { return ProjectInfo::projectName; }
    const String getApplicationVersion() override    { return ProjectInfo::versionString; }
    bool moreThanOneInstanceAllowed() override       { return true; }

    //==============================================================================
    void initialise (const String& commandLine) override
    {
        // This method is where you should put your application's initialisation code..
		commandLine;

        mainWindow = new MainWindow (getApplicationName(), adm);

		// create socket info
		struct lws_context_creation_info info;
		info.port = 80;
		info.iface = "";
		info.protocols = protocols;
		info.extensions = libwebsocket_get_internal_extensions();
		info.ssl_cert_filepath = NULL;
		info.ssl_private_key_filepath = NULL;
		info.gid = -1;
		info.uid = -1;
		info.options = 0;

		// create socket context from info
		struct libwebsocket_context *context = libwebsocket_create_context(&info);
		if (context == NULL) {
			lwsl_err("libwebsocket init failed\n");
			//return -1;
			return;
		}

		// run server
		while (1) {
			libwebsocket_service(context, 10);
			// libwebsocket_service will process all waiting events with their
			// callback functions and then wait 50 ms.
			// (this is a single threaded webserver and this will keep our server
			// from generating load while there are not requests to process)
		}

		libwebsocket_context_destroy(context);
    }

    void shutdown() override
    {
        // Add your application's shutdown code here..

        mainWindow = nullptr; // (deletes our window)
    }

    //==============================================================================
    void systemRequestedQuit() override
    {
        // This is called when the app is being asked to quit: you can ignore this
        // request and let the app carry on running, or call quit() to allow the app to close.
        quit();
    }

    void anotherInstanceStarted (const String& commandLine) override
    {
		commandLine;
        // When another instance of the app is launched while this one is running,
        // this method is invoked, and the commandLine parameter tells you what
        // the other instance's command-line arguments were.
    }

    //==============================================================================
    /*
        This class implements the desktop window that contains an instance of
        our MainContentComponent class.
    */
    class MainWindow    : public DocumentWindow
    {
    public:
        MainWindow (String name, AudioDeviceManager& adm) :
			adm(adm),
			DocumentWindow (name, Colours::lightgrey, DocumentWindow::allButtons)
        {
            setUsingNativeTitleBar (true);
            setContentOwned (new MIDISelectorComponent(adm), true);

            centreWithSize (getWidth(), getHeight());
            setVisible (true);
        }

        void closeButtonPressed() override
        {
            // This is called when the user tries to close this window. Here, we'll just
            // ask the app to quit when this happens, but you can change this to do
            // whatever you need.
            JUCEApplication::getInstance()->systemRequestedQuit();
        }

        /* Note: Be careful if you override any DocumentWindow methods - the base
           class uses a lot of them, so by overriding you might break its functionality.
           It's best to do all your work in your content component instead, but if
           you really have to override any DocumentWindow methods, make sure your
           subclass also calls the superclass's method.
        */

    private:
		AudioDeviceManager& adm;

		JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(MainWindow)
    };

private:
    ScopedPointer<MainWindow> mainWindow;
	AudioDeviceManager adm;
};

//==============================================================================
// This macro generates the main() routine that launches the app.
START_JUCE_APPLICATION (audience_pianoApplication)
